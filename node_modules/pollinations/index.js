/**
* A Node.js package that allows you to easily access all Pollinations features,
* including image generation and LLM capabilities, using their free API.
*
* @module pollinations
*/

const EventEmitter = require('node:events');
const { EventSource } = require('eventsource');
const axios = require("axios");
const picocolors = require("picocolors");
const Table = require('cli-table3');

class Pollinations extends EventEmitter {

    /**
    * Initializes the Pollinations API client.
    *
    * @param {Object} options - Configuration options for the client.
    * @param {string} [options.imageEndpoint="https://image.pollinations.ai"] - The base URL of the Pollinations API (Images).
    * @param {string} [options.textEndpoint="https://text.pollinations.ai"] - The base URL of the Pollinations API (LLMs).
    * @param {boolean} [options.debug=false] - Enable or disable debug logging.
    */
    constructor(options = {}) {
        super();
        this.imageEndpoint = options.imageEndpoint || "https://image.pollinations.ai";
        this.textEndpoint = options.textEndpoint || "https://text.pollinations.ai"
        this.debug = options.debug || false;
    }

    _debugLog(message) {
        if (this.debug) {
            const urlPattern = /(https?:\/\/[^\s]+)/g;
            const formattedMessage = message.replace(urlPattern, (url) => picocolors.greenBright(url));

            console.log(`${picocolors.yellow("[ðŸ Pollinations]")} ${formattedMessage}`);
        }
    }

    _debugWarning(message) {
        if (this.debug) {
            const urlPattern = /(https?:\/\/[^\s]+)/g;
            const formattedMessage = message.replace(urlPattern, (url) => picocolors.red(url));

            console.log(`${picocolors.yellow("[POLLINATIONS - WARNING]")} ${formattedMessage}`);
        }
    }

    _debugError(message) {
        if (this.debug) {
            const urlPattern = /(https?:\/\/[^\s]+)/g;
            const formattedMessage = message.replace(urlPattern, (url) => picocolors.yellow(url));

            console.log(`${picocolors.bgRed("[POLLINATIONS - ERROR]")} ${formattedMessage}`);
        }
    }

    /**
    * Image-related features and utilities.
    *
    * @namespace images
    */
    images = {
        /**
        * Fetches a list of available image generation models.
        *
        * @returns {Promise<string[]>} A promise that resolves to an array of model names.
        *
        * @example
        * const pollinations = new Pollinations();
        * pollinations.images.getModels()
        *   .then(models => console.log(models));
        *   // Example output:
        *   // [
        *   //   'flux',
        *   //   'flux-realism',
        *   //   'flux-cablyai',
        *   //   'flux-anime',
        *   //   'flux-3d',
        *   //   'any-dark',
        *   //   'flux-pro',
        *   //   'turbo'
        *   // ]
        *   .catch(error => console.error(error));
        */
        getModels: () => {
            return new Promise((resolve, reject) => {
                this._debugLog("Fetching models from " + this.imageEndpoint + "/models...");
                axios
                    .get(`${this.imageEndpoint}/models`)
                    .then((response) => {
                        this._debugLog(`Successfully fetched ${response.data.length} models: ${response.data.join(", ")}`);
                        resolve(response.data)
                    })
                    .catch((error) => reject("Failed to fetch models: " + error));
            });
        },

        /**
        * Generates an image based on the given prompt and options.
        *
        * @param {Object} options - The options for image generation.
        * @param {string} options.prompt - The text prompt for image generation.
        * @param {string} [options.model="flux"] - The model to use for image generation.
        * @param {number} [options.seed=null] - The seed for random generation (optional).
        * @param {number} [options.width=512] - The width of the generated image in pixels.
        * @param {number} [options.height=512] - The height of the generated image in pixels.
        * @param {boolean} [options.nologo=false] - Whether to remove the logo from the image.
        * @param {boolean} [options.private=false] - Whether the image is private.
        * @param {boolean} [options.enhance=false] - Whether to apply enhancement to the image.
        * @param {boolean} [options.safe=false] - Whether to apply safety filters to the image.
        * @returns {Promise<Buffer>} A promise that resolves to the generated image file (as a Buffer).
        *
        * @example
        * const pollinations = new Pollinations();
        * pollinations.images.generateImage({
        *   prompt: "A futuristic city at sunset",
        *   model: "flux-anime",
        *   width: 1024,
        *   height: 768
        * })
        * .then(image => {
        *   // The image is a Buffer; you can save or process it further
        *   require('fs').writeFileSync('generated-image.png', image);
        * })
        * .catch(error => console.error(error));
        */
        generateImage: ({
            prompt,
            model,
            seed,
            width,
            height,
            nologo,
            isPrivate,
            enhance,
            safe,
        }) => {
            // Assign default values
            model = model || "flux";
            seed = seed || Math.floor(Math.random() * 10000000000);;
            width = width || 512;
            height = height || 512;
            nologo = nologo || false;
            isPrivate = isPrivate || false;
            enhance = enhance || false;
            safe = safe || false;

            // Helper function to validate and set default values
            function validateOption(option, expectedType, defaultValue, paramName) {
                if (typeof option !== expectedType) {
                    this._debugWarning(`Expected a ${expectedType} for ${paramName}, got ${typeof option} instead. Defaulting to ${defaultValue}.`);
                    return defaultValue;
                }
                return option;
            }

            // Options validation
            prompt = typeof prompt === "string" ? prompt : (this._debugError("Prompt must be a string."), Promise.reject("Prompt must be a string."));
            model = validateOption.call(this, model, "string", "flux", "model");
            seed = validateOption.call(this, seed, "number", Math.floor(Math.random() * 10000000000), "seed");
            width = validateOption.call(this, width, "number", 512, "width");
            height = validateOption.call(this, height, "number", 512, "height");
            nologo = validateOption.call(this, nologo, "boolean", false, "nologo");
            isPrivate = validateOption.call(this, isPrivate, "boolean", false, "isPrivate");
            enhance = validateOption.call(this, enhance, "boolean", false, "enhance");
            safe = validateOption.call(this, safe, "boolean", false, "safe");

            const encodedPrompt = encodeURIComponent(prompt);

            // Construct the query string by concatenating all parameters
            const params = new URLSearchParams({
                model,
                seed,
                width,
                height,
                nologo,
                isPrivate,
                enhance,
                safe,
            }).toString();

            const url = `${this.imageEndpoint}/prompt/${encodedPrompt}?${params}`;

            return new Promise((resolve, reject) => {
                axios
                    .get(url, { responseType: "arraybuffer" })
                    .then((response) => resolve(response.data))
                    .catch((error) => reject("Failed to generate image: " + error));
            });
        }
    };

    /**
     * LLM-related features and utilities.
     *
     * @namespace llm
     */
    llm = {

        /**
        * Fetches a list of available text generation models.
        *
        * @returns {Promise<string[]>} A promise that resolves to an array of model names.
        *
        * @example
        * const pollinations = new Pollinations();
        * pollinations.llm.getModels()
        *   .then(models => console.log(models))
        *   // Example output:
        *   // [
        *   //     {
        *   //         "name": "openai",
        *   //         "type": "chat", 
        *   //         "censored": true,
        *   //         "description": "OpenAI GPT-4o-mini",
        *   //         "baseModel": true,
        *   //         "vision": true
        *   //     },
        *   //     {
        *   //         "name": "openai-large",
        *   //         "type": "chat",
        *   //         "censored": true,
        *   //         "description": "OpenAI GPT-4o",
        *   //         "baseModel": true,
        *   //         "vision": true
        *   //     }
        *   // ]
        *   .catch(error => console.error(error));
        */
        getModels: () => {
            return new Promise((resolve, reject) => {
                this._debugLog("Fetching models from " + this.textEndpoint + "/models...");
                axios
                    .get(`${this.textEndpoint}/models`)
                    .then((response) => {

                        if (this.debug) {
                            this._debugLog(`Successfully fetched ${response.data.length} models.`);
                            const table = new Table({
                                head: ['Name', 'Type', 'Description', 'Censored?', 'Base Model?', 'Vision?'],
                                colWidths: [20, 15, 50, 15, 15, 15],
                            });

                            response.data.forEach(model => {
                                table.push([model.name, model.type, model.description, model.censored ? 'Yes' : 'No', model.baseModel ? 'Yes' : 'No', model.vision ? 'Yes' : 'No']);
                            });

                            console.log(table.toString());
                        }

                        resolve(response.data)
                    })
                    .catch((error) => reject("Failed to fetch models: " + error));
            });
        },

        /**
         * Generates text based on the given prompt and options.
         *
         * @param {Object} options - The options for text generation.
         * @param {string} options.prompt - The text prompt for generation.
         * @param {string} [options.model="openai"] - The model to use for text generation.
         * @param {number} [options.seed=null] - The seed for random generation (optional).
         * @param {boolean} [options.json=false] - Whether to return the response as JSON.
         * @param {string} [options.system=""] - The system message (optional).
         * @returns {Promise<string>} A promise that resolves to the generated text.
         *
         * @example
         * const pollinations = new Pollinations();
         * pollinations.llm.generateTextGet({
         *   prompt: "Tell me a joke",
         *   model: "openai",
         *   seed: 12345
         * })
         * .then(text => console.log(text))
         * .catch(error => console.error(error));
         */
        generateTextGet: ({
            prompt,
            model,
            seed,
            json,
            system,
        }) => {
            // Assign default values
            model = model || "openai";
            seed = seed || Math.floor(Math.random() * 10000000000);
            json = json || false;
            system = system || "";

            // Helper function to validate and set default values
            function validateOption(option, expectedType, defaultValue, paramName) {
                if (typeof option !== expectedType) {
                    this._debugWarning(`Expected a ${expectedType} for ${paramName}, got ${typeof option} instead. Defaulting to ${defaultValue}.`);
                    return defaultValue;
                }
                return option;
            }

            // Options validation
            prompt = typeof prompt === "string" ? prompt : (this._debugError("Prompt must be a string."), Promise.reject("Prompt must be a string."));
            model = validateOption.call(this, model, "string", "openai", "model");
            seed = validateOption.call(this, seed, "number", Math.floor(Math.random() * 10000000000), "seed");
            json = validateOption.call(this, json, "boolean", false, "json");
            system = validateOption.call(this, system, "string", "", "system");

            const encodedPrompt = encodeURIComponent(prompt);

            // Construct the query string by concatenating all parameters
            const params = new URLSearchParams({
                model,
                seed,
                json,
                system,
            }).toString();

            const url = `${this.textEndpoint}/${encodedPrompt}?${params}`;

            return new Promise((resolve, reject) => {
                this._debugLog(`Generating text from ${url}...`);
                axios
                    .get(url)
                    .then((response) => {
                        this._debugLog(`Successfully generated text: ${response.data.length} characters long.`);
                        resolve(response.data);
                    })
                    .catch((error) => {
                        this._debugError(`Failed to generate text: ${error}`);
                        reject("Failed to generate text: " + error)
                    });
            });
        },

        /**
         * Generates text based on the given messages and options.
         *
         * @param {Object} options - The options for text generation.
         * @param {Array} options.messages - The array of messages to send as the conversation history.
         * @param {string} [options.model="openai"] - The model to use for text generation.
         * @param {number} [options.seed=null] - The seed for random generation (optional).
         * @param {boolean} [options.jsonMode=false] - Whether to return the response in JSON format.
         * @returns {Promise<string>} A promise that resolves to the generated text.
         *
         * @example
         * const pollinations = new Pollinations();
         * pollinations.llm.generateTextPost({
         *   messages: [{ role: "user", content: "Hello, who are you?" }],
         *   model: "openai",
         *   jsonMode: true
         * })
         * .then(text => console.log(text))
         * .catch(error => console.error(error));
         */
        generateTextPost: ({ messages, model, seed, jsonMode }) => {
            // Assign default values
            model = model || "openai";
            seed = seed || Math.floor(Math.random() * 10000000000);
            jsonMode = jsonMode || false;

            // Validate messages
            if (!Array.isArray(messages) || messages.length === 0) {
                this._debugError("Messages must be an array and cannot be empty.");
                return Promise.reject("Messages must be an array and cannot be empty.");
            }

            // Construct the request payload
            const payload = {
                messages,
                model,
                seed,
                jsonMode
            };

            return new Promise((resolve, reject) => {
                axios
                    .post(`${this.textEndpoint}/`, payload)
                    .then((response) => {
                        if (jsonMode) {
                            resolve(response.data);
                        } else {
                            resolve(response.data.text);
                        }
                    })
                    .catch((error) => reject("Failed to generate text: " + error));
            });
        },

    }

    /**
     * Event emitted when image feed data is received.
     *
     * @event Pollinations#imageFeed
     * @type {Object} 
     * @property {number} width - The width of the generated image.
     * @property {number} height - The height of the generated image.
     * @property {number} seed - The seed used for the image generation process.
     * @property {string} model - The model used for generating the image.
     * @property {boolean} nologo - Indicates if the image should have a logo.
     * @property {string} negative_prompt - The negative prompt to improve the image.
     * @property {boolean} nofeed - Whether the feed should be active.
     * @property {boolean} safe - Indicates whether the image is safe for general audiences.
     * @property {number} concurrentRequests - The number of concurrent requests handled.
     * @property {string} imageURL - The URL of the generated image.
     * @property {string} prompt - The original text prompt for generating the image.
     * @property {string} originalPrompt - The original input text prompt (same as `prompt`).
     * @property {boolean} isChild - Indicates if this is a child image (subsequent to the original).
     * @property {boolean} isMature - Indicates if the generated image is mature in content.
     * @property {Array} timingInfo - An array of timestamps for each generation step.
     * @property {string} ip - The IP address associated with the request.
     * @property {string} status - The current status of the image generation process.
     * @property {boolean} wasPimped - Indicates if the image was altered or enhanced in some way.
     */

    /**
     * Connect to the image feed SSE stream.
     */
    connectImagesFeed() {
        const url = "https://image.pollinations.ai/feed";

        try {
            const eventSource = new EventSource(url);

            eventSource.onmessage = (event) => {
                if (this.debug) {
                    this._debugLog("Received an event from the Image feed: " + event.data);
                }

                try {
                    const data = JSON.parse(event.data);
                    this.emit("imageFeed", data);
                } catch (err) {
                    console.error("Failed to parse event data:", err);
                }
            };

            eventSource.onerror = (error) => {
                console.error("Error connecting to the feed:", error);
                eventSource.close();
            };

            this.eventSource = eventSource;
        } catch (err) {
            console.error("Failed to connect to the feed:", err);
        }
    }


    /**
     * Event emitted when text feed data is received.
     *
     * @event Pollinations#textFeed
     * @type {Object} 
     * @property {string} response - The generated response text.
     * @property {Object} parameters - The parameters associated with the request.
     * @property {Array} parameters.messages - An array of messages in the conversation.
     * @property {Object} parameters.messages[] - Each message in the array.
     * @property {string} parameters.messages[].content - The content of the message.
     * @property {string} parameters.messages[].role - The role of the sender ("user", "assistant", or "system").
     * @property {boolean} parameters.jsonMode - Whether the response is in JSON mode.
     * @property {number} parameters.seed - The seed used for the text generation process.
     * @property {string} parameters.model - The model used for generating the text response.
     * @property {boolean} parameters.isImagePollinationsReferrer - Whether the referrer is Pollinations for images.
     * @property {boolean} parameters.isRobloxReferrer - Whether the referrer is Roblox.
     * @property {string} parameters.referrer - The platform that referred the request (e.g., "roblox").
     * @property {boolean} parameters.stream - Whether the text is streamed.
     * @property {boolean} parameters.plaintTextResponse - Whether the response is plain text.
     * @property {number} parameters.completion_tokens - The number of tokens used for the completion.
     * @property {Object} parameters.completion_tokens_details - Details of token usage for the completion.
     * @property {number} parameters.completion_tokens_details.accepted_prediction_tokens - Tokens used for accepted predictions.
     * @property {number} parameters.completion_tokens_details.audio_tokens - Tokens used for audio.
     * @property {number} parameters.completion_tokens_details.reasoning_tokens - Tokens used for reasoning.
     * @property {number} parameters.completion_tokens_details.rejected_prediction_tokens - Tokens used for rejected predictions.
     * @property {number} parameters.prompt_tokens - The number of tokens used for the prompt.
     * @property {Object} parameters.prompt_tokens_details - Details of token usage for the prompt.
     * @property {number} parameters.prompt_tokens_details.audio_tokens - Tokens used for audio in the prompt.
     * @property {number} parameters.prompt_tokens_details.cached_tokens - Cached tokens for the prompt.
     * @property {number} parameters.total_tokens - The total number of tokens used (prompt + completion).
     */

    /**
     * Connect to the text feed SSE stream.
     */
    connectTextFeed() {
        const url = "https://text.pollinations.ai/feed";

        try {
            const eventSource = new EventSource(url);

            eventSource.onmessage = (event) => {
                if (this.debug) {
                    this._debugLog("Received an event from the Text feed: " + event.data);
                }

                try {
                    const data = JSON.parse(event.data);
                    this.emit("textFeed", data);
                } catch (err) {
                    console.error("Failed to parse event data:", err);
                }
            };

            eventSource.onerror = (error) => {
                console.error("Error connecting to the feed:", error);
                eventSource.close();
            };

            this.eventSource = eventSource;
        } catch (err) {
            console.error("Failed to connect to the feed:", err);
        }
    }

}

module.exports = Pollinations;